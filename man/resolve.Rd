% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/resolve.R
\name{resolve}
\alias{resolve}
\title{Resolve content from a content identifier}
\usage{
resolve(
  id,
  verify = TRUE,
  verify_local = FALSE,
  registries = default_registries(),
  ...
)
}
\arguments{
\item{id}{A content identifier, see \verb{[content_uri]}}

\item{verify}{logical, default \verb{[TRUE]}. Should we verify that
downloaded content matches the requested hash?}

\item{verify_local}{logical, default \verb{[FALSE]}. Should we verify
that local content matches the requested hash?
contenturi's \code{store} is indexed by content identifier,
so we can skip this step if we trust the integrity of
the local disk storage.}

\item{registries}{list of registries at which to register the URL}

\item{...}{additional arguments to \verb{[query_local]} or \verb{[query_remote]}.}
}
\description{
Requested content can be found at mutiple locations:
cached to disk, or available at one or more URLs.  This function
provides a mechanism to always return a single, local path to the
content requested, (provided the content identifier can be found in
at least one of the registries).
}
\details{
Local storage
is checked first as it will allow us to bypass downloading content
when a local copy is available. If no local copy is found but
one or more remote URLs are registered for the hash, downloads
from these will be attempted in order from most recent first.
}
\examples{

# ensure some content in local storage for testing purposes:
vostok_co2 <- system.file("extdata", "vostok.icecore.co2",
                          package = "contenturi")
store(vostok_co2)


resolve(paste0(
 "hash://sha256/9412325831dab22aeebdd6",
 "74b6eb53ba6b7bdd04bb99a4dbb21ddff646287e37")
)

}
\seealso{
query query_local query_remote
}
